<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Professional Project Mapper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        @property --angle {
          syntax: '<angle>';
          initial-value: 0deg;
          inherits: false;
        }

        :root {
            --angle: 0deg;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #e5e7eb;
            overflow: hidden;
            overscroll-behavior: none;
        }

        .glow-border {
            position: fixed; inset: 0; padding: 2px;
            background: conic-gradient(from var(--angle), #0d0d0d, #1a1a1a, #6366f1, #a855f7, #ec4899, #6366f1, #1a1a1a, #0d0d0d);
            animation: rotate 20s linear infinite;
            z-index: -1;
        }

        @keyframes rotate { to { --angle: 360deg; } }

        #app-container {
            background-color: #0a0a0a;
            background-image: radial-gradient(#1a1a1a 1px, transparent 1px);
            background-size: 16px 16px;
        }

        .ui-panel {
            background: rgba(20, 20, 20, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .node-box {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background-image: url('data:image/svg+xml,%3Csvg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%" height="100%" filter="url(%23noise)" opacity="0.03"/%3E%3C/svg%3E');
            background-size: cover;
            background-position: center;
            position: relative;
        }
        .node-box.has-background::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Dark overlay for readability */
            border-radius: 0.5rem; /* Corresponds to rounded-lg */
            z-index: 0;
        }
        .node-box .content-container, .node-box .absolute {
            position: relative;
            z-index: 1;
        }
        .node-box.drag-over {
            border-color: #a855f7;
            border-style: dashed;
        }
        .node-box:hover { box-shadow: 0 0 20px rgba(79, 70, 229, 0.4); }
        .connector-point {
            width: 14px; height: 14px; background-color: #1a1a1a; border: 2px solid #4f46e5; border-radius: 50%; position: absolute; cursor: crosshair; transition: all 0.2s ease; z-index: 10;
        }
        .connector-point:hover { transform: scale(1.5); background-color: #6366f1; }
        .connector-point.top { top: -7px; left: 50%; transform: translateX(-50%); }
        .connector-point.bottom { bottom: -7px; left: 50%; transform: translateX(-50%); }
        .connector-point.left { left: -7px; top: 50%; transform: translateY(-50%); }
        .connector-point.right { right: -7px; top: 50%; transform: translateY(-50%); }

        .content-container iframe, .content-container img, .content-container video { pointer-events: none; }
        
        .connector-path { stroke: url(#wireGradient); stroke-width: 2.5px; fill: none; stroke-linecap: round; cursor: pointer; transition: stroke-width 0.2s ease, filter 0.2s ease; }
        .connector-path.selected { stroke-width: 4px; filter: drop-shadow(0 0 3px #a855f7); }
        .connector-path-temp { stroke: #a855f7; stroke-width: 2.5px; fill: none; stroke-dasharray: 5 5; stroke-linecap: round; }
        
        .delete-icon-group { cursor: pointer; }
        .delete-icon-bg { fill: #ef4444; transition: fill 0.2s ease; }
        .delete-icon-group:hover .delete-icon-bg { fill: #dc2626; }
        .delete-icon-path { stroke: white; stroke-width: 2; }

        .toast { animation: fadeInOut 3s ease-in-out forwards; }
        @keyframes fadeInOut { 0%, 100% { opacity: 0; transform: translateY(20px); } 10%, 90% { opacity: 1; transform: translateY(0); } }
        #sidebar { transition: transform 0.3s ease-in-out; }
    </style>
</head>
<body class="w-screen h-screen">
    <div class="glow-border"></div>
    <div id="app-container" class="relative w-full h-full">

        <!-- Sidebar -->
        <div id="sidebar" class="absolute top-0 left-0 h-full w-64 ui-panel z-30 transform -translate-x-full">
            <div class="p-4 flex flex-col h-full">
                <h2 class="text-xl font-bold mb-4">Projects</h2>
                <ul id="project-list" class="flex-grow overflow-y-auto"></ul>
            </div>
        </div>
        <button id="sidebar-toggle" class="absolute top-4 left-4 z-40 p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-md transition">
            <i data-lucide="menu"></i>
        </button>

        <!-- Main Canvas -->
        <div id="canvas" class="relative w-full h-full overflow-hidden">
            <svg id="connector-svg" class="absolute top-0 left-0 w-full h-full">
                <defs>
                    <linearGradient id="wireGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#4f46e5;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#a855f7;stop-opacity:1" />
                    </linearGradient>
                </defs>
            </svg>
            <div id="project-title" class="absolute bottom-4 left-1/2 -translate-x-1/2 text-gray-400 text-lg font-semibold">Unsaved Project</div>
        </div>

        <!-- Toolbar -->
        <div class="absolute top-4 left-1/2 -translate-x-1/2 flex items-center gap-2 p-2 rounded-lg ui-panel">
            <button id="new-btn" class="p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-md transition" title="New Project"><i data-lucide="file-plus-2"></i></button>
            <button id="save-btn" class="p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-md transition" title="Save Project"><i data-lucide="save"></i></button>
            <div class="w-px h-6 bg-white/20 mx-2"></div>
            <button id="add-box-btn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-md font-semibold transition flex items-center gap-2">
                <i data-lucide="plus-circle" class="w-5 h-5"></i> Add Node
            </button>
        </div>

        <!-- Modals -->
        <div id="content-modal" class="hidden fixed inset-0 z-50 items-center justify-center bg-black/70">
            <div class="ui-panel rounded-lg p-8 w-full max-w-md">
                <h2 class="text-2xl font-bold mb-6 text-center">Add Content</h2>
                <div class="grid grid-cols-2 gap-4">
                    <button data-type="text" class="content-type-btn p-4 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition flex items-center justify-center gap-2"><i data-lucide="type"></i>Text</button>
                    <button data-type="link" class="content-type-btn p-4 bg-purple-600 hover:bg-purple-700 rounded-lg transition flex items-center justify-center gap-2"><i data-lucide="link"></i>Link</button>
                    <button data-type="image" class="content-type-btn p-4 bg-pink-600 hover:bg-pink-700 rounded-lg transition flex items-center justify-center gap-2"><i data-lucide="image"></i>Image URL</button>
                    <button data-type="video" class="content-type-btn p-4 bg-teal-600 hover:bg-teal-700 rounded-lg transition flex items-center justify-center gap-2"><i data-lucide="youtube"></i>Video Embed</button>
                    <button data-type="upload" class="content-type-btn p-4 bg-orange-600 hover:bg-orange-700 rounded-lg transition col-span-2 flex items-center justify-center gap-2"><i data-lucide="upload-cloud"></i>Upload File</button>
                </div>
                <button id="close-content-modal-btn" class="mt-6 w-full py-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition">Cancel</button>
            </div>
        </div>
        
        <div id="input-modal" class="hidden fixed inset-0 z-50 items-center justify-center bg-black/70">
             <div class="ui-panel rounded-lg p-8 w-full max-w-md">
                <h2 id="input-modal-title" class="text-2xl font-bold mb-4 text-center">Input</h2>
                <input id="input-modal-field" type="text" class="w-full bg-gray-900/50 border border-white/20 rounded-md p-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <div class="flex gap-4 mt-6">
                    <button id="input-modal-cancel" class="w-full py-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition">Cancel</button>
                    <button id="input-modal-submit" class="w-full py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition">Submit</button>
                </div>
            </div>
        </div>
        <div id="color-palette-modal" class="hidden fixed inset-0 z-50 items-center justify-center bg-black/70">
            <div class="ui-panel rounded-lg p-6 w-full max-w-xs">
                <h2 class="text-xl font-bold mb-4 text-center">Set Border Color</h2>
                <div id="color-grid" class="grid grid-cols-5 gap-3"></div>
                <button id="close-color-modal-btn" class="mt-6 w-full py-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition">Cancel</button>
            </div>
        </div>
        <div id="toast-container" class="fixed bottom-5 right-5 z-50"></div>
        <input type="file" id="file-upload-input" class="hidden" accept="image/*,video/mp4,video/webm">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Setup ---
            lucide.createIcons();
            const canvas = document.getElementById('canvas');
            const connectorSvg = document.getElementById('connector-svg');
            
            // --- State ---
            let boxes = [], connectors = [], nextBoxId = 0, activeBoxForContent = null, isDragging = false, dragTarget = null, offset = { x: 0, y: 0 }, mousePos = { x: 0, y: 0 }, animationFrameId = null, isConnecting = false, startConnector = null, tempLine = null, selectedConnector = null, activeBoxForColor = null, currentProjectName = null;
            let uploadTarget = 'content'; // Can be 'content' or 'background'

            // --- UI Elements ---
            const fileUploadInput = document.getElementById('file-upload-input');
            
            // --- Universal Pointer Position Helper ---
            function getPointerPosition(event) {
                if (event.touches && event.touches.length > 0) {
                    return { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                return { x: event.clientX, y: event.clientY };
            }

            // --- Animation Loop for Smoother Dragging ---
            function animationLoop() {
                if (isDragging && dragTarget) {
                    const boxData = boxes.find(b => b.element === dragTarget);
                    if (boxData) {
                        const canvasRect = canvas.getBoundingClientRect();
                        let targetX = mousePos.x - canvasRect.left - offset.x;
                        let targetY = mousePos.y - canvasRect.top - offset.y;
                        targetX = Math.max(0, Math.min(targetX, canvas.clientWidth - dragTarget.offsetWidth));
                        targetY = Math.max(0, Math.min(targetY, canvas.clientHeight - dragTarget.offsetHeight));
                        const easeFactor = 0.2;
                        boxData.x += (targetX - boxData.x) * easeFactor;
                        boxData.y += (targetY - boxData.y) * easeFactor;
                        dragTarget.style.left = `${boxData.x}px`;
                        dragTarget.style.top = `${boxData.y}px`;
                        updateAllConnectors();
                    }
                }

                if (isConnecting && startConnector && tempLine) {
                    const startCoords = getConnectorCoordinates(startConnector.boxId, startConnector.point);
                    const canvasRect = canvas.getBoundingClientRect();
                    const endCoords = { x: mousePos.x - canvasRect.left, y: mousePos.y - canvasRect.top };
                    if(startCoords) tempLine.setAttribute('d', calculateCurvePath(startCoords, endCoords, startConnector.point, ''));
                }

                if (isDragging || isConnecting) animationFrameId = requestAnimationFrame(animationLoop);
                else { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            }
            function startAnimationLoop() { if (!animationFrameId) animationFrameId = requestAnimationFrame(animationLoop); }

            // --- Box Management ---
            function createBox(x, y, id = null, contentHTML = null, borderColor = null, backgroundImage = null) {
                const boxId = id !== null ? id : nextBoxId++;
                if (id !== null && id >= nextBoxId) nextBoxId = id + 1;
                
                const box = document.createElement('div');
                box.id = `box-${boxId}`;
                box.className = 'node-box absolute p-4 rounded-lg w-64 min-h-[120px] flex flex-col cursor-grab select-none';
                box.style.left = `${x}px`; box.style.top = `${y}px`;
                if (borderColor) box.style.borderColor = borderColor;
                if (backgroundImage) {
                    box.style.backgroundImage = backgroundImage;
                    box.classList.add('has-background');
                }

                box.innerHTML = `
                    <div class="flex-grow content-container overflow-y-auto" style="max-height: 200px;">
                        ${contentHTML || '<div class="content-placeholder text-gray-400 text-center p-4">Click to add content</div>'}
                    </div>
                    <div class="absolute top-0 right-0 -mt-3 -mr-3 z-20 flex gap-1">
                         <button class="background-box-btn w-7 h-7 bg-gray-700 text-white rounded-full flex items-center justify-center hover:bg-gray-600 transition shadow-lg"><i data-lucide="image" class="w-4 h-4"></i></button>
                         <button class="color-box-btn w-7 h-7 bg-gray-700 text-white rounded-full flex items-center justify-center hover:bg-gray-600 transition shadow-lg"><i data-lucide="palette" class="w-4 h-4"></i></button>
                         <button class="delete-box-btn w-7 h-7 bg-red-600 text-white rounded-full flex items-center justify-center hover:bg-red-700 transition shadow-lg"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                    </div>
                    <div class="connector-point top"></div> <div class="connector-point bottom"></div> <div class="connector-point left"></div> <div class="connector-point right"></div>
                `;

                canvas.appendChild(box);
                lucide.createIcons({ nodes: [box.querySelector('.delete-box-btn'), box.querySelector('.color-box-btn'), box.querySelector('.background-box-btn')] });
                const boxData = { id: boxId, element: box, x: x, y: y };
                boxes.push(boxData);
                setupBoxEventListeners(box, boxData);
                return boxData;
            }
            
            function setupBoxEventListeners(boxElement, boxData) {
                const handleDragStart = (e) => {
                    if (e.target.closest('.delete-box-btn, .color-box-btn, .background-box-btn, .connector-point, .content-container')) return;
                    e.preventDefault();
                    isDragging = true; dragTarget = boxElement; dragTarget.classList.add('cursor-grabbing');
                    boxData.x = boxElement.offsetLeft; boxData.y = boxElement.offsetTop;
                    const pos = getPointerPosition(e);
                    offset.x = pos.x - boxElement.getBoundingClientRect().left;
                    offset.y = pos.y - boxElement.getBoundingClientRect().top;
                    startAnimationLoop();
                };
                boxElement.addEventListener('mousedown', handleDragStart);
                boxElement.addEventListener('touchstart', handleDragStart, { passive: false });

                const handleConnectorStart = (e) => {
                    e.stopPropagation(); e.preventDefault();
                    isConnecting = true; 
                    startConnector = { boxId: boxData.id, point: getPointPosition(e.target) }; 
                    tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
                    tempLine.setAttribute('class', 'connector-path-temp'); 
                    connectorSvg.appendChild(tempLine); 
                    startAnimationLoop();
                };
                boxElement.querySelectorAll('.connector-point').forEach(point => {
                    point.addEventListener('mousedown', handleConnectorStart);
                    point.addEventListener('touchstart', handleConnectorStart, { passive: false });
                });
                
                // Right-click to delete last connector
                boxElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    deleteLastConnectorFromNode(boxData);
                });

                // Long-press to delete last connector
                let longPressTimer;
                boxElement.addEventListener('touchstart', (e) => {
                    if (e.target.closest('.delete-box-btn, .color-box-btn, .background-box-btn, .connector-point, .content-container, .connector-path')) return;
                    longPressTimer = setTimeout(() => {
                        deleteLastConnectorFromNode(boxData);
                    }, 500);
                }, { passive: true });
                boxElement.addEventListener('touchend', () => clearTimeout(longPressTimer));
                boxElement.addEventListener('touchmove', () => clearTimeout(longPressTimer));


                boxElement.addEventListener('dragover', (e) => { e.preventDefault(); boxElement.classList.add('drag-over'); });
                boxElement.addEventListener('dragleave', () => boxElement.classList.remove('drag-over'));
                boxElement.addEventListener('drop', (e) => { e.preventDefault(); boxElement.classList.remove('drag-over'); const file = e.dataTransfer.files[0]; if (file) handleFileUpload(file, boxData); });
                
                boxElement.querySelector('.delete-box-btn').addEventListener('click', () => deleteBox(boxData.id));
                boxElement.querySelector('.color-box-btn').addEventListener('click', () => { activeBoxForColor = boxData; document.getElementById('color-palette-modal').classList.remove('hidden'); });
                boxElement.querySelector('.background-box-btn').addEventListener('click', () => { activeBoxForContent = boxData; uploadTarget = 'background'; fileUploadInput.accept = 'image/*'; fileUploadInput.click(); });
                boxElement.querySelector('.content-container').addEventListener('click', (e) => { if(e.target.classList.contains('content-placeholder') || e.target.classList.contains('content-container')) { activeBoxForContent = boxData; document.getElementById('content-modal').classList.remove('hidden'); } });
            }

            function deleteLastConnectorFromNode(boxData) {
                let connectorIndex = -1;
                for (let i = connectors.length - 1; i >= 0; i--) {
                    if (connectors[i].start.boxId === boxData.id) {
                        connectorIndex = i;
                        break;
                    }
                }

                if (connectorIndex !== -1) {
                    const connectorToRemove = connectors[connectorIndex];
                    if (selectedConnector === connectorToRemove) deselectConnector();
                    connectorToRemove.path.remove();
                    connectorToRemove.deleteIcon.remove();
                    connectors.splice(connectorIndex, 1);
                    showToast('Last connector removed.', 'info');
                }
            }

            function deleteBox(boxId) { const i = boxes.findIndex(b => b.id === boxId); if (i > -1) { boxes[i].element.remove(); boxes.splice(i, 1); connectors = connectors.filter(c => { if (c.start.boxId === boxId || c.end.boxId === boxId) { if (selectedConnector === c) deselectConnector(); c.deleteIcon.remove(); c.path.remove(); return false; } return true; }); updateAllConnectors(); } }

            function handleFileUpload(file, boxData) {
                if (file.size > 5 * 1024 * 1024) { showToast('File is too large (max 5MB).', 'error'); return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    let contentHtml = '';
                    if (file.type.startsWith('image/')) { contentHtml = `<img src="${dataUrl}" class="w-full h-auto rounded-md object-cover">`; }
                    else if (file.type.startsWith('video/')) { contentHtml = `<video src="${dataUrl}" controls class="w-full h-auto rounded-md"></video>`; }
                    else { showToast('Unsupported file type.', 'warning'); return; }
                    addContentToBox(boxData, contentHtml);
                };
                reader.readAsDataURL(file);
                addContentToBox(boxData, `<div class="text-gray-400">Loading...</div>`);
            }
            
            function handleBackgroundImageUpload(file, boxData) {
                if (!file.type.startsWith('image/')) { showToast('Only image files can be used as backgrounds.', 'warning'); return; }
                if (file.size > 5 * 1024 * 1024) { showToast('Image file is too large (max 5MB).', 'error'); return; }
                 const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    boxData.element.style.backgroundImage = `url(${dataUrl})`;
                    boxData.element.classList.add('has-background');
                };
                reader.readAsDataURL(file);
            }

            fileUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && activeBoxForContent) {
                    if (uploadTarget === 'background') {
                        handleBackgroundImageUpload(file, activeBoxForContent);
                    } else {
                        handleFileUpload(file, activeBoxForContent);
                    }
                }
            });

            // --- Global Pointer/Touch Event Handlers ---
            const handlePointerMove = (e) => { mousePos = getPointerPosition(e); };
            const handlePointerUp = (e) => {
                if(isDragging){ dragTarget.classList.remove('cursor-grabbing'); isDragging=false; dragTarget=null; } 
                if(isConnecting){
                    if(tempLine)tempLine.remove(); tempLine=null;
                    const endTarget = document.elementFromPoint(mousePos.x, mousePos.y);
                    const endBoxElement = endTarget ? endTarget.closest('.node-box') : null;

                    if (endBoxElement) {
                        const endId = parseInt(endBoxElement.id.split('-')[1]);
                        const startBox = boxes.find(b => b.id === startConnector.boxId).element;

                        if (startBox !== endBoxElement) {
                            const closestPoint = findClosestPoint(endBoxElement, mousePos);
                            const endConn = { boxId: endId, point: closestPoint };
                            createConnector(startConnector, endConn);
                        }
                    }
                    isConnecting=false; startConnector=null;
                } 
            };
            document.addEventListener('mousemove', handlePointerMove);
            document.addEventListener('touchmove', (e) => { handlePointerMove(e); }, { passive: false });
            document.addEventListener('mouseup', handlePointerUp);
            document.addEventListener('touchend', handlePointerUp);

            // --- Content & Color Modals ---
            function addContentToBox(boxData, html) { boxData.element.querySelector('.content-container').innerHTML = html; }
            function setupColorPalette() {
                const colors = ['#FFFFFF', '#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef'];
                const colorGrid = document.getElementById('color-grid');
                colorGrid.innerHTML = '';
                colors.forEach(color => {
                    const swatch = document.createElement('button');
                    swatch.className = 'w-10 h-10 rounded-full cursor-pointer transition transform hover:scale-110';
                    swatch.style.backgroundColor = color;
                    swatch.addEventListener('click', () => { if (activeBoxForColor) { activeBoxForColor.element.style.borderColor = color; document.getElementById('color-palette-modal').classList.add('hidden'); activeBoxForColor = null; } });
                    colorGrid.appendChild(swatch);
                });
                const defaultSwatch = document.createElement('button');
                defaultSwatch.className = 'w-10 h-10 rounded-full cursor-pointer transition transform hover:scale-110 flex items-center justify-center bg-gray-500';
                defaultSwatch.innerHTML = `<i data-lucide="x" class="w-6 h-6"></i>`;
                defaultSwatch.addEventListener('click', () => { if (activeBoxForColor) { activeBoxForColor.element.style.borderColor = 'rgba(255, 255, 255, 0.1)'; document.getElementById('color-palette-modal').classList.add('hidden'); activeBoxForColor = null; } });
                colorGrid.appendChild(defaultSwatch);
                lucide.createIcons({ nodes: [defaultSwatch] });
            }
            document.getElementById('close-color-modal-btn').addEventListener('click', () => { document.getElementById('color-palette-modal').classList.add('hidden'); activeBoxForColor = null; });
            document.querySelectorAll('#content-modal .content-type-btn').forEach(btn => btn.addEventListener('click', () => handleContentButtonClick(btn.dataset.type)));
            document.getElementById('close-content-modal-btn').addEventListener('click', () => document.getElementById('content-modal').classList.add('hidden'));
            
            function handleContentButtonClick(type) {
                document.getElementById('content-modal').classList.add('hidden');
                if (!activeBoxForContent) return;
                if (type === 'upload') {
                    uploadTarget = 'content';
                    fileUploadInput.accept = 'image/*,video/mp4,video/webm';
                    fileUploadInput.click();
                    return;
                }
                const prompts = { text: null, link: "Enter URL", image: "Enter Image URL", video: "Enter YouTube/Vimeo Embed URL" };
                if (type === 'text') {
                    const contentContainer = activeBoxForContent.element.querySelector('.content-container');
                    contentContainer.innerHTML = '';
                    const textDiv = document.createElement('div');
                    textDiv.className = 'content-editable text-white p-1 outline-none min-h-[50px]';
                    textDiv.contentEditable = true;
                    const placeholder = "Start typing...";
                    textDiv.textContent = placeholder;

                    textDiv.addEventListener('focus', () => {
                        if (textDiv.textContent === placeholder) {
                            textDiv.textContent = '';
                        }
                    });

                    textDiv.addEventListener('blur', () => {
                        if (textDiv.textContent.trim() === '') {
                            textDiv.textContent = placeholder;
                        }
                    });

                    contentContainer.appendChild(textDiv);
                    textDiv.focus();
                } else {
                    showInputModal(prompts[type], "", (value) => {
                        if (value) {
                            const html = type === 'link' ? `<a href="${value}" target="_blank" class="text-indigo-400 hover:underline break-all">${value}</a>` :
                                type === 'image' ? `<img src="${value}" class="w-full h-auto rounded-md object-cover" onerror="this.parentElement.innerHTML = '<p class=\\'text-red-400\\'>Invalid Image URL</p>';">` :
                                `<iframe src="${value.includes('watch?v=') ? value.replace('watch?v=', 'embed/') : value}" class="w-full aspect-video rounded-md" frameborder="0" allowfullscreen></iframe>`;
                            addContentToBox(activeBoxForContent, html);
                        }
                    });
                }
            }

            let inputModalCallback = null;
            function showInputModal(title, placeholder, callback) {
                const modal = document.getElementById('input-modal');
                modal.querySelector('#input-modal-title').textContent = title;
                const field = modal.querySelector('#input-modal-field');
                field.value = ''; field.placeholder = placeholder;
                modal.classList.remove('hidden'); field.focus();
                inputModalCallback = callback;
            }
            document.getElementById('input-modal-submit').addEventListener('click', () => { if(inputModalCallback) inputModalCallback(document.getElementById('input-modal-field').value); document.getElementById('input-modal').classList.add('hidden'); });
            document.getElementById('input-modal-cancel').addEventListener('click', () => document.getElementById('input-modal').classList.add('hidden'));

            // --- Connector Management ---
            function getPointPosition(p) { if(p.classList.contains('top')) return 'top'; if(p.classList.contains('bottom')) return 'bottom'; if(p.classList.contains('left')) return 'left'; return 'right'; }
            function getConnectorCoordinates(boxId, pos) { const b = boxes.find(bx=>bx.id===boxId); if(!b) return null; const r = b.element.getBoundingClientRect(); let x=b.x, y=b.y; switch(pos){ case 'top': return {x:x+r.width/2, y:y}; case 'bottom': return {x:x+r.width/2, y:y+r.height}; case 'left': return {x:x, y:y+r.height/2}; case 'right': return {x:x+r.width, y:y+r.height/2}; } }
            function updateAllConnectors() { connectors.forEach(c => { const s=getConnectorCoordinates(c.start.boxId, c.start.point), e=getConnectorCoordinates(c.end.boxId, c.end.point); if(s&&e) { const pathString = calculateCurvePath(s,e,c.start.point,c.end.point); c.path.setAttribute('d', pathString); const mid = getBezierMidpoint(s, e, c.start.point, c.end.point); c.deleteIcon.setAttribute('transform', `translate(${mid.x}, ${mid.y})`); } }); }
            function calculateCurvePath(s, e, sPos, ePos) { const dx=e.x-s.x, dy=e.y-s.y; let cx1=s.x,cy1=s.y,cx2=e.x,cy2=e.y; const cf=Math.min(Math.abs(dx),Math.abs(dy))*0.5+40; if(sPos==='left'||sPos==='right')cx1+=(sPos==='left'?-1:1)*cf; else cy1+=(sPos==='top'?-1:1)*cf; if(ePos==='left'||ePos==='right')cx2+=(ePos==='left'?1:-1)*cf; else cy2+=(ePos==='top'?1:-1)*cf; return `M ${s.x} ${s.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${e.x} ${e.y}`; }
            function getBezierMidpoint(start, end, startPos, endPos) {
                const dx=end.x-start.x, dy=end.y-start.y; let cx1=start.x,cy1=start.y,cx2=end.x,cy2=end.y; const cf=Math.min(Math.abs(dx),Math.abs(dy))*0.5+40; if(startPos==='left'||startPos==='right')cx1+=(startPos==='left'?-1:1)*cf; else cy1+=(startPos==='top'?-1:1)*cf; if(endPos==='left'||endPos==='right')cx2+=(endPos==='left'?1:-1)*cf; else cy2+=(endPos==='top'?1:-1)*cf;
                const t = 0.5; const t2 = t*t; const t3 = t2*t; const mt = 1-t; const mt2 = mt*mt; const mt3 = mt2*mt;
                const x = (start.x * mt3) + (3 * cx1 * mt2 * t) + (3 * cx2 * mt * t2) + (end.x * t3);
                const y = (start.y * mt3) + (3 * cy1 * mt2 * t) + (3 * cy2 * mt * t2) + (end.y * t3);
                return { x, y };
            }
            function findClosestPoint(boxElement, pointerPos) {
                const rect = boxElement.getBoundingClientRect();
                const points = {
                    top: { x: rect.left + rect.width / 2, y: rect.top },
                    bottom: { x: rect.left + rect.width / 2, y: rect.bottom },
                    left: { x: rect.left, y: rect.top + rect.height / 2 },
                    right: { x: rect.right, y: rect.top + rect.height / 2 }
                };
                let closestSide = null; let minDistance = Infinity;
                for (const side in points) {
                    const point = points[side];
                    const dx = pointerPos.x - point.x; const dy = pointerPos.y - point.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq < minDistance) { minDistance = distanceSq; closestSide = side; }
                }
                return closestSide;
            }
            function deselectConnector() { if(selectedConnector){selectedConnector.path.classList.remove('selected'); selectedConnector.deleteIcon.style.display = 'none'; selectedConnector=null;} }
            function createConnector(start, end) { 
                const path = document.createElementNS('http://www.w3.org/2000/svg','path'); 
                path.setAttribute('class','connector-path'); 
                path.style.pointerEvents='stroke';
                
                const deleteIcon = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                deleteIcon.setAttribute('class', 'delete-icon-group');
                deleteIcon.style.display = 'none';
                deleteIcon.innerHTML = `
                    <circle class="delete-icon-bg" cx="0" cy="0" r="12"/>
                    <path class="delete-icon-path" d="M9 9l6 6M15 9l-6 6" transform="translate(-12, -12) scale(0.75)"/>
                `;
                
                connectorSvg.appendChild(path);
                connectorSvg.appendChild(deleteIcon);
                
                const d={start:start,end:end,path:path, deleteIcon: deleteIcon}; 
                
                path.addEventListener('click', e=>{e.stopPropagation();deselectConnector();selectedConnector=d;path.classList.add('selected'); deleteIcon.style.display = 'block'; });
                deleteIcon.addEventListener('click', e => {
                    e.stopPropagation();
                    const i = connectors.indexOf(d);
                    if (i > -1) connectors.splice(i, 1);
                    path.remove();
                    deleteIcon.remove();
                    showToast('Connector deleted', 'info');
                });

                connectors.push(d); 
                updateAllConnectors(); 
            }
            
            // --- Project Management & UI ---
            function showToast(message, type = 'info') { const colors = { success: 'bg-green-500', info: 'bg-blue-500', warning: 'bg-yellow-500', error: 'bg-red-500' }; const toast = document.createElement('div'); toast.className = `toast text-white px-4 py-2 rounded-md shadow-lg ${colors[type]}`; toast.textContent = message; document.getElementById('toast-container').appendChild(toast); setTimeout(() => toast.remove(), 3000); }
            function clearCanvas() { boxes.forEach(b => b.element.remove()); connectors.forEach(c => { c.path.remove(); c.deleteIcon.remove(); }); boxes = []; connectors = []; selectedConnector = null; nextBoxId = 0; }
            function updateProjectTitle(name) { currentProjectName = name; document.getElementById('project-title').textContent = name || 'Unsaved Project'; }
            function saveState() { showInputModal('Save Project', currentProjectName || 'Enter project name...', (projectName) => { if (!projectName) { showToast('Save cancelled.', 'warning'); return; } const state = { boxes: boxes.map(b => ({ id: b.id, x: b.x, y: b.y, contentHTML: b.element.querySelector('.content-container').innerHTML, borderColor: b.element.style.borderColor, backgroundImage: b.element.style.backgroundImage })), connectors: connectors.map(c => ({ start: c.start, end: c.end })), nextBoxId: nextBoxId }; let allProjects = JSON.parse(localStorage.getItem('projectMapperProjects')) || {}; allProjects[projectName] = state; localStorage.setItem('projectMapperProjects', JSON.stringify(allProjects)); updateProjectTitle(projectName); populateSidebar(); showToast(`Project "${projectName}" Saved!`, 'success'); }); }
            function loadState(projectName) { let allProjects = JSON.parse(localStorage.getItem('projectMapperProjects')) || {}; const state = allProjects[projectName]; if (state) { clearCanvas(); nextBoxId = state.nextBoxId || 0; (state.boxes || []).forEach(b => createBox(b.x, b.y, b.id, b.contentHTML, b.borderColor, b.backgroundImage)); (state.connectors || []).forEach(c => createConnector(c.start, c.end)); updateAllConnectors(); updateProjectTitle(projectName); showToast(`Project "${projectName}" Loaded!`, 'info'); } else { showToast(`Could not find project "${projectName}".`, 'error'); } }
            function deleteProject(projectName) { if (confirm(`Delete "${projectName}"?`)) { let allProjects = JSON.parse(localStorage.getItem('projectMapperProjects')) || {}; delete allProjects[projectName]; localStorage.setItem('projectMapperProjects', JSON.stringify(allProjects)); if (currentProjectName === projectName) { clearCanvas(); updateProjectTitle(null); createBox(200, 150); } populateSidebar(); showToast(`Project "${projectName}" deleted.`, 'info'); } }
            function populateSidebar() { let allProjects = JSON.parse(localStorage.getItem('projectMapperProjects')) || {}; const projectNames = Object.keys(allProjects); const projectList = document.getElementById('project-list'); projectList.innerHTML = ''; if (projectNames.length === 0) { projectList.innerHTML = '<li class="text-gray-400 p-2">No saved projects.</li>'; return; } projectNames.forEach(name => { const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2 rounded-md hover:bg-white/10 cursor-pointer'; li.innerHTML = `<span>${name}</span><button class="delete-project-btn p-1 text-gray-400 hover:text-red-500"><i data-lucide="trash-2" class="w-4 h-4"></i></button>`; li.addEventListener('click', (e) => { if (!e.target.closest('.delete-project-btn')) { loadState(name); document.getElementById('sidebar').classList.add('-translate-x-full'); } }); li.querySelector('.delete-project-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteProject(name); }); projectList.appendChild(li); }); lucide.createIcons({ nodes: projectList.querySelectorAll('.delete-project-btn') }); }
            
            // --- Init & Event Listeners ---
            document.getElementById('add-box-btn').addEventListener('click', () => createBox(canvas.clientWidth / 2 - 128, canvas.clientHeight / 2 - 60));
            document.getElementById('new-btn').addEventListener('click', () => { if (confirm('Start a new project?')) { clearCanvas(); updateProjectTitle(null); createBox(200, 150); showToast('New project started.', 'info'); } });
            document.getElementById('save-btn').addEventListener('click', saveState);
            document.getElementById('sidebar-toggle').addEventListener('click', () => document.getElementById('sidebar').classList.toggle('-translate-x-full'));
            canvas.addEventListener('click', deselectConnector);
            document.addEventListener('keydown', e => { if((e.key==='Delete'||e.key==='Backspace')&&selectedConnector){ const i=connectors.indexOf(selectedConnector); if(i>-1)connectors.splice(i,1); selectedConnector.path.remove(); selectedConnector.deleteIcon.remove(); selectedConnector=null; showToast('Connector deleted','info'); } });
            
            // --- Initial Load ---
            setupColorPalette();
            populateSidebar();
            createBox(200, 150);
        });
    </script>
</body>
</html>

